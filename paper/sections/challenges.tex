% !TEX root = ../main.tex

\section{Challenges}
\label{sec:challenges}

\paragraph{Smart contract correctness}
All executable code is subject to bugs: developer errors that can be taken advantage of to hijack program logic. This problem manifests in smart contracts, and when those contracts control the transference of valuable assets, the impact of a bug can be devastating. The immutability of the blockchain exacerbates this challenge by impeding rollback of state changes, even those that are clearly malicious (see Limitations below). This is because by definition, any transactions on a blockchain upon which consensus is reached are considered legal - including buggy code and exploitations of such. If "code is law", as claimed by a blockchain-based investment fund called the Decentralized Autonomous Organization (DAO), then so are bugs. 

This principle was put to the test in June 2016 when the DAO was drained of about \$80m in tokens. Targeting a smart contract that first moved funds and then updated account balance, the attacker exploited a vulnerability to recursively execute the contract in between those two steps. Repeatedly moving funds without ever checking account balances allowed the attacker to move more funds than were authorized. In response, the DAO developers implemented a "hard fork" from a state before the attack occurred. This created two blockchains: one in which the funds had never been drained and another in which the attacker still held their spoils \cite{Castillo16}. Of course, this rollback contradicts the perception that the blockchain is immutable and settled contracts are final; we will discuss this contradiction later as a key limitation of Blockchain technology. The challenge is how to ensure smart contract correctness so that code really can be law.

The first step to ensuring smart contract correctness is to produce a precise specification for the functionality and safety properties of the contract. This provides a baseline against which correctness can be evaluated; if there is no specification (as was the case for the DAO), then there is truly no way to distinguish undesired or malicious activity because anything the code permits is valid. Once a specification has been developed, the contract's correctness can be validated using formal verification techniques. Some of these techniques, such as model-checking, have an additional pitfall: the specification and the code are developed independently, so precise correspondence between the two must be carefully maintained.

Some of the underlying work necessary to support mainstream development of formally verified smart contracts is underway; for example, the Ethereum Virtual Machine (EVM) has been fully defined for interactive theorem provers \cite{Hirai17}, which are essential tools for building formally verified software of any kind. Magazzeni et. al \cite{Magazzeni17} have laid out a research agenda identifying further groundwork that must be conducted to support formal verification of smart contracts.

\paragraph{Consistency of off-chain assets and corresponding on-chain tokens}
When a blockchain is used to track off-chain assets (physical or digital), those assets are typically represented on-chain by digital tokens. When dealing with digital assets, correspondence between the asset and its token can generally be maintained by code; for example, a smart contract can track transference of ownership for a digital media license. For physical assets, however, maintaining this consistency is a challenge. Real-world processes must be employed to ensure that whenever an asset's state or ownership is modified, the corresponding token is updated. These processes are an obvious point of failure as they rely on correct enforcement by trusted parties. The person in charge of maintaining the blockchain could attach two tokens to one asset, two assets to one token, or issue tokens that have no backing asset (e.g. stocks in a naked short selling scenario). The end user must also be trusted, as they may be able to separate the token and sell it while keeping the asset, freeing the token to be attached to an invalid asset (e.g., fake goods in luxury markets). 

\paragraph{Dispute resolution and rollback of mistakes}
A payment or asset transfer system must be able to reverse fraudulent or mistaken transactions. The immutability property of Blockchain means that transactions cannot be stricken from the ledger after consensus has been reached, so alternative means of dispute resolution must be explored. A new transaction reversing the effects of the disputed transaction could be added to the ledger, but decentralized governance makes arbitrating such a dispute difficult as there is no individual arbiter with the authority to determine which party is in the right when a dispute occurs. 

\paragraph{Non-auditability of off-chain oracles}
Smart contracts sometimes leverage off-chain oracles: online services that provide information in response to a request. For example, gambling contracts may determine which address to pay winnings to based on the result of some oracle request (e.g., sports scores, stock prices, weather forecasts, or other global events). If contract logic branches based on the response from an off-chain oracle, that contract is no longer verifiable after the fact because auditors cannot confirm that the response received from the oracle at audit time is the same response received when the contract was executed. There are legitimate reasons why an oracle response might change with time, so this is really an inherent limitation of Blockchain technology: smart contracts cannot "see" external events.

One system tackling this problem is Town Crier \cite{Zhang16}. It uses a trusted hardware back end (Intel SGX) to serve as an authenticated off-chain oracle for Ethereum smart contracts. This allows an auditor to later verify the oracle's response at the time at which the contract was executed. This solution sidesteps the limitation of oracle non-auditability by moving trust to a centralized location (the hardware platform providing authenticity), but it does not diffuse trust in the way our analysis reveals that Blockchain technology is expected to.

\paragraph{Scalability of public blockchains: transaction costs and bandwidth, emergent centralization, and energy consumption}
As the Bitcoin user base and transaction volume have grown, limitations on its scalability have been revealed. To some degree, these limitations are a result of Bitcoin's chosen parameters; for example, the 1MB cap on block size has periodically caused prohibitively high transaction fees and wait times. This limitation was mitigated by the Bitcoin Cash hard fork in 2017, which created 8MB blocks, but other scalability problems may not be so easily solvable by simple parameter tweaking, suggesting that they may be inherent limitations of public blockchain technology. We will discuss two limitations that stem from the proof-of-work consensus model that is typically used in public blockchains: emergent centralization of control and high rates of energy consumption.

Currently, almost 70\% of Bitcoin blocks are mined by the five largest pools \cite{BlockchainInfoPools}. Of course, these pools are disincentivized to damage trust in Bitcoin (and thus reduce its value and their profits) by abusing their power to censor transactions or violate rules in other ways. But this centralization undoubtedly runs counter to the normative property that Blockchain is decentralized and may violate security notions that depend on decentralization. This problem is caused in part by the hardware-optimized Bitcoin mining puzzle, for which alternatives are being explored, but whether or not this limitation can be overcome at scale is still an open question.

Bitcoin is also an illustrative example for another inefficiency of public blockchains at scale: the energy consumption of proof-of-work consensus. According to one estimate\cite{Digiconomist}, as of April 2018 the energy consumed by Bitcoin miners is equivalent to the power usage of almost 5.5 million US households, and all signs indicate that it will continue to grow. A similar problem is likely to arise in any scheme where proof-of-work is deployed. It may be surpassable if alternative consensus protocols such as proof-of-stake are used, but there are other problems to work out with such schemes (in particular, a worsening of the emergent centralization problem discussed above). 

